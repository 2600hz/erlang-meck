{"name":"Meck","body":"meck\r\n====\r\nA mocking library for Erlang.\r\n\r\nIntroduction\r\n------------\r\n\r\nWith meck you can easily mock modules in Erlang. You can also perform\r\nsome basic validations on the mocked modules, such as making sure no\r\nunexpected exceptions occurred or looking at the call history.\r\n\r\nFeatures\r\n--------\r\n\r\n  * Automatic renaming and restoration of original modules\r\n  * Automatic backup and restore of cover data\r\n  * Changing return values using sequences and loops of static values\r\n  * Pass through: use functions from the original module\r\n  * Mock is linked to the creating process (disable with `no_link`)\r\n  * Complete call history showing calls, results and exceptions\r\n  * Mocking of sticky modules (using the option `unstick`)\r\n  * Throwing of expected exceptions that keeps the module valid\r\n\r\nExamples\r\n--------\r\nHere's an example of using meck in the Erlang shell:\r\n\r\n```erl\r\nEshell V5.8.4  (abort with ^G)\r\n1> meck:new(dog).\r\nok\r\n2> meck:expect(dog, bark, fun() -> \"Woof!\" end).\r\nok\r\n3> dog:bark().\r\n\"Woof!\"\r\n4> meck:validate(dog).\r\ntrue\r\n5> meck:unload(dog).\r\nok\r\n6> dog:bark().\r\n** exception error: undefined function dog:bark/0\r\n```\r\n\r\nExceptions can be anticipated by meck (resulting in validation still\r\npassing). This is intended to be used to test code that can and should\r\nhandle certain exceptions indeed does take care of them:\r\n\r\n```erl\r\n5> meck:expect(dog, meow, fun() -> meck:exception(error, not_a_cat) end).\r\nok\r\n6> catch dog:meow().\r\n{'EXIT',{not_a_cat,[{meck,exception,2},\r\n                    {meck,exec,4},\r\n                    {dog,meow,[]},\r\n                    {erl_eval,do_apply,5},\r\n                    {erl_eval,expr,5},\r\n                    {shell,exprs,6},\r\n                    {shell,eval_exprs,6},\r\n                    {shell,eval_loop,3}]}}\r\n7> meck:validate(dog).\r\ntrue\r\n```\r\n\r\nNormal Erlang exceptions result in a failed validation. The following\r\nexample is just to demonstrate the behavior, in real test code the\r\nexception would normally come from the code under test (which should,\r\nif not expected, invalidate the mocked module):\r\n\r\n```erl\r\n8> meck:expect(dog, jump, fun(Height) when Height > 3 ->\r\n                                  erlang:error(too_high);\r\n                             (Height) ->\r\n                                  ok\r\n                          end).\r\nok\r\n9> dog:jump(2).\r\nok\r\n10> catch dog:jump(5).\r\n{'EXIT',{too_high,[{meck,exec,4},\r\n                   {dog,jump,[5]},\r\n                   {erl_eval,do_apply,5},\r\n                   {erl_eval,expr,5},\r\n                   {shell,exprs,6},\r\n                   {shell,eval_exprs,6},\r\n                   {shell,eval_loop,3}]}}\r\n11> meck:validate(dog).\r\nfalse\r\n```\r\n\r\nHere's an example of using meck inside an EUnit test case:\r\n\r\n```erlang\r\nmy_test() ->\r\n    meck:new(my_library_module),\r\n    meck:expect(my_library_module, fib, fun(8) -> 21 end),\r\n    ?assertEqual(21, code_under_test:run(fib, 8)), % Uses my_library_module\r\n    ?assert(meck:validate(my_library_module)),\r\n    meck:unload(my_library_module).\r\n```\r\n\r\nPass-through is used when the original functionality of a module\r\nshould be kept. When the option `passthrough` is used when calling\r\n`new/2` all functions in the original module will be kept in the\r\nmock. These can later be overridden by calling `expect/3` or\r\n`expect/4`.\r\n\r\n```erl\r\nEshell V5.8.4  (abort with ^G)\r\n1> meck:new(string, [unstick, passthrough]).\r\nok\r\n2> string:strip(\"  test  \").\r\n\"test\"\r\n```\r\n\r\nIt's also possible to pass calls to the original function allowing us\r\nto override only a certain behavior of a function (this usage is\r\ncompatible with the `passthrough` option). `passthrough/1` will always\r\ncall the original function with the same name as the expect is \r\ndefined in):\r\n\r\n```erl\r\nEshell V5.8.4  (abort with ^G)\r\n1> meck:new(string, [unstick]).\r\nok\r\n2> meck:expect(string, strip, fun(String) -> meck:passthrough([String]) end).\r\nok\r\n3> string:strip(\"  test  \").\r\n\"test\"\r\n4> meck:unload(string).\r\nok\r\n5> string:strip(\"  test  \").\r\n\"test\"\r\n```\r\n\r\nBuild\r\n-----\r\n\r\n[![Build Status](https://secure.travis-ci.org/eproxus/meck.png)](http://travis-ci.org/eproxus/meck)\r\n\r\nmeck requires [rebar][1] to build. To build meck, go to the meck\r\ndirectory and simply type:\r\n\r\n```sh\r\nrebar compile\r\n```\r\n\r\nTo make sure meck works on your platform, run the tests:\r\n\r\n```sh\r\nrebar eunit\r\n```\r\n\r\nTwo things might seem alarming when running the tests:\r\n\r\n  1. Warnings emitted by cover\r\n  2. En exception printed by SASL\r\n\r\nBoth are expected due to the way Erlang currently prints errors. The\r\nimportant line you should look for is `All XX tests passed`, if that\r\nappears all is correct.\r\n\r\nInstall\r\n-------\r\n\r\nTo install meck permanently, use of [Agner][2] is recommended:\r\n\r\n```sh\r\nagner install meck\r\n```\r\n\r\nIf you want to install your own built version of meck add the ebin\r\ndirectory to your Erlang code path or move the meck folder into your\r\nrelease folder and make sure that folder is in your `ERL_LIBS`\r\nenvironment variable.\r\n\r\nContribute\r\n----------\r\n\r\nPatches are greatly appreciated!\r\n\r\nShould you find yourself using meck and have issues, comments or\r\nfeedback please [create an issue here on GitHub.] [3]\r\n\r\n  [1]: https://github.com/basho/rebar \"Rebar - A build tool for Erlang\"\r\n  [2]: http://erlagner.org/ \"Agner - Erlang Package Index & Package Manager\"\r\n  [3]: http://github.com/eproxus/meck/issues \"meck issues\"\r\n","tagline":"A mocking library for Erlang","google":"UA-336094-3","note":"Don't delete this file! It's used internally to help with page regeneration."}